# text extracting libraries
from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
from pdfminer.converter import TextConverter
from pdfminer.layout import LAParams
from pdfminer.pdfpage import PDFPage
from io import StringIO


import os
from dotenv import load_dotenv
import qdrant_client
from qdrant_client import models, QdrantClient
import cohere
from qdrant_client.http.models import Batch

from app.users.models import VectorDBId
from app import db

load_dotenv(dotenv_path= os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env'))


class store_resume:
    def __init__(self, name, email, phone_no, file_path):
        self.name = name
        self.email = email
        self.phone_no = phone_no
        self.file_path = file_path


    def extract_text_from_pdf(self):
        resource_manager = PDFResourceManager()
        return_str = StringIO()
        layout_params = LAParams()
        device = TextConverter(resource_manager, return_str, laparams=layout_params)
        interpreter = PDFPageInterpreter(resource_manager, device)

        fp = open(self.file_path, 'rb')

        password = ""
        max_pages = 0
        caching = True
        page_nos = set()
        for page in PDFPage.get_pages(fp, page_nos, maxpages=max_pages, password=password, caching=caching,
                                        check_extractable=True):
            interpreter.process_page(page)

        text = return_str.getvalue().lower()
        return text


    def insert_resume(self):
        text = self.extract_text_from_pdf()

        cohere_client = cohere.Client(os.getenv("COHERE_API_KEY"))
        qdrant_client = QdrantClient(
            url=os.getenv("QDRANT_URL"),
            api_key=os.getenv("QDRANT_API_KEY"),
        )

        embeddings_response = cohere_client.embed(
            texts=[text],
            model="embed-english-v3.0",
            input_type="search_document"
        )

        vectors = [
            # Conversion to float is required for Qdrant
            list(map(float, vector)) 
            for vector in embeddings_response.embeddings
        ]
        
        record = VectorDBId.query.first()
        id = record.id

        record.id = id + 1
        db.session.commit()

        document = [
            {
                "name": self.name,
                "phone_no": self.phone_no,
                "email": self.email
            }
        ]


        # Filling up Qdrant collection with the embeddings generated by Cohere co.embed API
        qdrant_client.upsert(
            collection_name="resume_v2", 
            points=Batch(
                ids=[id],
                vectors=vectors,
                payloads=document,
            )
        )


class search_candidates_vector_db:
    def __init__(self, job_description):
        self.job_description = job_description

    def search(self):
        cohere_client = cohere.Client(os.getenv("COHERE_API_KEY"))
        qdrant_client = QdrantClient(
            url=os.getenv("QDRANT_URL"),
            api_key=os.getenv("QDRANT_API_KEY"),
        )

        hits = qdrant_client.search(
            collection_name="resume_v2",
            query_vector=cohere_client.embed(
                model="embed-english-v3.0",  # New Embed v3 model
                input_type="search_query",  # Input type for search queries
                texts=[self.job_description],
            ).embeddings[0],
        )

        result = list()

        for hit in hits:
            result.append({"payload":hit.payload, "score":hit.score})
            print(hit.payload, "score:", hit.score)

        return result
    

def create_new_cluster(collection_name):
    qdrant_client = QdrantClient(
            url=os.getenv("QDRANT_URL"),
            api_key=os.getenv("QDRANT_API_KEY"),
        )

    qdrant_client.create_collection(
        collection_name=f"{collection_name}",
        vectors_config=models.VectorParams(size=1024, distance=models.Distance.COSINE),
        optimizers_config=models.OptimizersConfigDiff(
            indexing_threshold=0,
        ),
)